
/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
@page moduleShortcuts  Shortcuts (for the impatient developper)

@writers Jacques-Olivier Lachaud

@since 1.0

Part of the \ref packageTutorials.
  
This part of the manual describes how to use shortcuts to quickly
create shapes and surfaces, to traverse surfaces, to save/load images
and shapes, and to analyze their geometry.

[TOC]


The following programs are related to this documentation:
shortcuts.cpp.

@section dgtal_shortcuts_sec1 Introduction

To use shortcuts, you must include the following header:

\code
#include "DGtal/helpers/Shortcuts.h"
\endcode

And choose an appropriate Khalimsky space according to the dimension
of the object you will be processing.

\code
// Using standard 2D digital space.
typedef Shortcuts<Z2i::KSpace> SH2;
// Using standard 3D digital space.
typedef Shortcuts<Z3i::KSpace> SH3;
\endcode

The general philosophy of the shorcut module is to choose reasonnable
data structures so as to minimize the number of lines to build
frequent digital geometry code. For instance, the following lines
builds a shape that represents the digitization of an ellipsoid.

\code
  auto params = SH3::defaultParameters();
  // Set your own parameters with operator().
  params( "polynomial", "3*x^2+2*y^2+z^2-90" )( "gridstep", 0.25 );
  auto implicit_shape  = SH3::makeImplicitShape3D( params );
  auto kspace          = SH3::makeKSpaceDigitizedImplicitShape3D( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  std::cout << *digitized_shape << std::endl;
\endcode

As one can see, a Parameters object stores parameter values and can be
simply updated by the user with the function operator().

Big objects (like images, shapes, surfaces) are always returned or
passed as smart pointers (with CountedPtr). Hence you do not have to
take care of their life-length and you do not need to delete them
explicitly.


@section dgtal_shortcuts_sec2 Short 3D examples

We give below some minimalistic examples to show that shortcuts can
save a lot of lines of code. All examples need at least the following lines:

\code
#include "DGtal/helpers/Stddefs.h"
#include "DGtal/helpers/Shortcuts.h"
...
// Using standard 3D digital space.
typedef Shortcuts<Z3i::KSpace> SH3;
auto params = SH3::defaultParameters();
\endcode

Examples requiring geometric functions (ground-truth or estimation) need the following lines (i.e. functions in `SHG3`):

\code
#include "DGtal/helpers/Stddefs.h"
#include "DGtal/helpers/Shortcuts.h"
#include "DGtal/helpers/ShortcutsGeometry.h"
...
// Using standard 3D digital space.
typedef Shortcuts<Z3i::KSpace>         SH3;
typedef ShortcutsGeometry<Z3i::KSpace> SHG3;
auto params = SH3::defaultParameters()
              | SHG3::defaultParameters();
\endcode


@subsection dgtal_shortcuts_ssec2_1 Load vol file -> ...

@subsubsection dgtal_shortcuts_ssec2_1_1 -> noisify -> save as vol file.

\code
  // load and noisify image directly.
  auto al_capone = SH3::makeBinaryImage( examplesPath + "samples/Al.100.vol", params( "noise", 0.3 ) );
  auto ok        = SH3::saveBinaryImage( al_capone, "noisy-Al.vol" );
\endcode 

@subsubsection dgtal_shortcuts_ssec2_1_2  -> build main connected digital surface

\code
  auto al_capone = SH3::makeBinaryImage( examplesPath + "samples/Al.100.vol", params );
  auto K         = SH3::getKSpace( al_capone );
  auto surface   = SH3::makeLightDigitalSurface( al_capone, K, params );
\endcode

@subsubsection dgtal_shortcuts_ssec2_1_3 -> extract 2 isosurfaces -> displays them with two different colors

\code
auto params   = SH3::defaultParameters();
params( "faceSubdivision", "Centroid" )( "surfelAdjacency", 1);
auto gimage   = SH3::makeGrayScaleImage( examplesPath + "samples/lobster.vol" );
auto trisurf40= SH3::makeTriangulatedSurface( gimage, params( "thresholdMin", 40 ) );
auto trisurf20= SH3::makeTriangulatedSurface( gimage, params( "thresholdMin", 20 ) );
auto mesh40   = SH3::makeMesh( trisurf40, Color::Red );
auto mesh20   = SH3::makeMesh( trisurf20, Color::Blue );
QApplication application(argc,argv);
Viewer3D<> viewer;
viewer.show();
viewer << *mesh40 << *mesh20;
viewer << Viewer3D<>::updateDisplay;
application.exec();
\endcode


@subsection dgtal_shortcuts_ssec2_2 Build polynomial shape -> ...

@subsubsection dgtal_shortcuts_ssec2_2_1 -> digitize -> noisify -> save as vol file.

\code
  // Set your own parameters with operator().
  params( "polynomial", "3*x^2+2*y^2+z^2-90" )
        ( "gridstep", 0.25 )
        ( "noise", 0.3 );
  auto implicit_shape  = SH3::makeImplicitShape3D  ( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  auto noisy_shape     = SH3::makeBinaryImage      ( digitized_shape, params );
  auto ok              = SH3::saveBinaryImage      ( noisy_shape, "noisy-ellipsoid.vol" );
\endcode 

@subsubsection dgtal_shortcuts_ssec2_2_2 -> digitize -> build indexed surface -> save primal surface as obj

\code
  params( "polynomial", "goursat" )( "gridstep", 0.25 );
  auto implicit_shape  = SH3::makeImplicitShape3D  ( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  auto K               = SH3::getKSpace( params );
  auto binary_image    = SH3::makeBinaryImage( digitized_shape, K, params );
  auto surface         = SH3::makeIdxDigitalSurface( binary_image, K, params );
  auto primal_surface  = SH3::makePrimalPolygonalSurface( surface, params );
  bool ok              = SH3::saveOBJ( primal_surface, "goursat-primal.obj" );
\endcode

@subsubsection dgtal_shortcuts_ssec2_2_3 -> digitize -> build indexed surface on a subpart

\code
  params( "polynomial", "3*x^2+2*y^2+z^2-90" )( "gridstep", 0.25 )
        ( "minAABB", -12.0 )( "maxAABB", 12.0 )
        ( "surfaceComponents", "All" ) );
  auto implicit_shape  = SH3::makeImplicitShape3D  ( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  auto Kwhole          = SH3::getKSpace( params );
  auto K               = SH3::getKSpace( SH3::Point::zero, Kwhole.upperBound(), params );
  auto binary_image    = SH3::makeBinaryImage( digitized_shape, 
                                               SH3::Domain(K.lowerBound(),K.upperBound()),
					       params );
  auto surface         = SH3::makeIdxDigitalSurface( binary_image, K, params );
\endcode

@subsubsection dgtal_shortcuts_ssec2_2_4 -> digitize -> extract ground-truth geometry

\code
  params( "polynomial", "3*x^2+2*y^2+z^2-90" )( "gridstep", 0.25 );
  auto implicit_shape  = SH3::makeImplicitShape3D  ( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  auto binary_shape    = SH3::makeBinaryImage      ( digitized_shape, params );
  auto K               = SH3::getKSpace( params );
  auto surface         = SH3::makeLightDigitalSurface( binary_image, K, params );
  auto surfels         = SH3::getSurfelRange( surface, params );
  auto positions       = SHG3::getPositions( implicit_shape, K, surfels, params );
  auto normals         = SHG3::getNormalVectors( implicit_shape, K, surfels, params );
  auto mean_curvs      = SHG3::getMeanCurvatures( implicit_shape, K, surfels, params );
  auto gauss_curvs     = SHG3::getGaussianCurvatures( implicit_shape, K, surfels, params );
\endcode

@subsubsection dgtal_shortcuts_ssec2_2_5 -> digitize -> extract mean curvature -> save as OBJ with colors

\code
  params( "polynomial", "goursat" )( "gridstep", 0.25 )( "Traversal", "Default" );
  auto implicit_shape  = SH3::makeImplicitShape3D  ( params );
  auto digitized_shape = SH3::makeDigitizedImplicitShape3D( implicit_shape, params );
  auto binary_shape    = SH3::makeBinaryImage      ( digitized_shape, params );
  auto K               = SH3::getKSpace( params );
  auto surface         = SH3::makeLightDigitalSurface( binary_image, K, params );
  auto surfels         = SH3::getSurfelRange( surface, params );
  auto mean_curv       = SHG3::getMeanCurvatures( implicit_shape, K, surfels, params );
  auto cmap            = SH3::getColorMap( -0.3, 0.3 );
  auto colors          = SH3::Colors( surfels.size() );
  for ( SH3::Idx i = 0; i < normals.size(); i++ ) colors[ i ] = cmap( mean_curv[ i ] ); 
  auto polysurf        = SH3::makePrimalPolygonalSurface( surface );
  bool ok              = SH3::saveOBJ( polysurf, SH3::RealVectors(), colors, "goursat-H.obj" );
\endcode

@subsubsection dgtal_shortcuts_ssec2_2_6 -> float image -> gray-scale image -> extract iso-surface -> save as OBJ file.

\code
  // Set your own parameters with operator().
  auto params   = SH3::defaultParameters  ();
  params( "polynomial", "goursat" )( "gridstep", 0.25 )( "thresholdMin", 128 );
  auto ishape   = SH3::makeImplicitShape3D( params );
  auto fimage   = SH3::makeFloatImage     ( ishape, params );
  auto gimage   = SH3::makeGrayScaleImage ( fimage, params );
  auto trisurf  = SH3::makeTriangulatedSurface( gimage, params );
  bool ok       = SH3::saveOBJ            ( trisurf, "goursat.obj" );
\endcode 


@section dgtal_shortcuts_sec2b Short 2D examples

We give below some minimalistic examples to show that shortcuts can
save a lot of lines of code. All examples need at least the following lines:

\code
#include "DGtal/helpers/Stddefs.h"
#include "DGtal/helpers/Shortcuts.h"

...
// Using standard 2D digital space.
typedef Shortcuts<Z2i::KSpace> SH2;
auto params          = SH2::defaultParameters();
\endcode

@subsection dgtal_shortcuts_ssec2b_1 Load pgm file -> ...

@subsubsection dgtal_shortcuts_ssec2b_1_1 -> threshold -> save pgm 

\code
auto g_image = SH2::makeGrayScaleImage( examplesPath + "samples/contourS.pgm" );
auto b_image = SH2::makeBinaryImage   ( g_image, params( "thresholdMin", 128 ) );
auto ok      = SH2::saveBinaryImage   ( b_image, "contourS-128.pgm" );
\endcode


@section dgtal_shortcuts_sec3 Philosophy and naming conventions

Commands are constructed as \b prefix + \b type name. Most of them are
static methods and are overloaded to accept different set of
parameters. 

@subsection dgtal_shortcuts_ssec3_1 Prefixes 

- \b make + `Type`: means that it will create a new object of type
  `Type` and returns it as a \e smart \e pointer onto it. Depending on
  parameters, \b make can \b load a file, \b copy and \b transform an
  object, \b build an empty/not object according to parameters.

- \b make + `Type` + \b s: means that it will create new objects of type
  `Type` and returns them as a vector of \e smart \e pointers onto it. 

- \b make + `Spec` + `Type`: means that it will create a new object of
  type `Type` with some specialized meaning according to `Spec` and
  returns it as a \e smart \e pointer onto it.

- \b save + `Type`: means that it will save the pointed object of type `Type` as a file.

- \b parameters + `Type`: returns the Parameters object associated to
  the operations related to the given `Type`.

- \b get + `Type`: means that it will return \e by \e value an object of type `Type`.

@subsection dgtal_shortcuts_ssec3_2 Types

The following name conventions for types are used:

- Shortcuts::Point: represents a point with integer coordinates.
- Shortcuts::Vector: represents a vector with integer coordinates.
- Shortcuts::RealPoint: represents a point with floating-point coordinates.
- Shortcuts::RealVector: represents a vector with floating-point coordinates.
- Shortcuts::Domain: represents an (hyper-)rectangular digital domain.
- Shortcuts::Integer: represents integer numbers (for Point coordinates and Vector components) 
- Shortcuts::Space: represents a digital space (generally a SpaceND)
- Shortcuts::KSpace: represents a cellular grid space (generally a KhalimskySpaceND)

- Shortcuts::ImplicitShape3D: represents a functor RealPoint -> Scalar which adds
  geometry services: isInside, orientation, gradient, meanCurvature,
  GaussianCurvature, principalCurvatures, nearestPoint

- Shortcuts::DigitizedImplicitShape3D: represents the digitization of an
  ImplicitShape3D as a predicate Point -> bool (isInside), and adds some
  services: getLowerBound, getUpperBound, embed, round, getDomain,
  gridSteps, resolution. Note that pixels/voxels are not stored
  explicitly, so the resolution may be arbirary high.

- Shortcuts::BinaryImage: represents a black and white image as an array of
  bits. It is generally a faster representation of a predicate Point
  -> bool than an implicit digital shape.

- Shortcuts::GrayScaleImage: represents an 8-bits gray-scale image as an array of
  bytes (unsigned char). 

- Shortcuts::FloatImage: represents a float image as an array of
  floats.

- Shortcuts::DoubleImage: represents a double image as an array of
  doubles.

- Shortcuts::LightDigitalSurface: represents a connected digital
  surface over a binary image with an implicit representation.

- Shortcuts::DigitalSurface: represents an arbitrary digital surface
  with an explicit surfel set representation.

- Shortcuts::IdxDigitalSurface: represents an indexed digital surface
  with an explicit array-like representation.

- Shortcuts::Mesh: represents a simple mesh with arbitrary faces, but
  without topology (should be used when no surface topology is needed
  or when working with non-manifold surfaces).

- Shortcuts::TriangulatedSurface: represents a triangulated surface
  which may have boundaries (use HalfEdgeDataStructure).

- Shortcuts::PolygonalSurface: represents a polygonal surface which
  may have boundaries (use HalfEdgeDataStructure).

- Shortcuts::Colormap: represents a colormap, i.e. a function
  assigning a color to a real value.

@subsection dgtal_shortcuts_ssec3_3 Main methods

-# General methods
  - Shortcuts::defaultParameters: return the set of all shorcut parameters.

-# ImplicitShape3D methods
  - Shortcuts::getPolynomialList: return the list of polynomial shapes predefined for implicit shapes 
  - Shortcuts::parametersImplicitShape3D: parameters related to 3D implicit shapes (polynomial)
  - Shortcuts::makeImplicitShape3D: builds a 3D implicit shape
  - Shortcuts::getPositions: returns the positions on the 3D implicit shape close to the specified surfels.
  - Shortcuts::getNormalVectors: returns the vectors normal to the 3D implicit shape close to the specified surfels.
  - Shortcuts::getMeanCurvatures: returns the mean curvatures along the 3D implicit shape close to the specified surfels.
  - Shortcuts::getGaussianCurvatures: returns the Gaussian curvatures along the 3D implicit shape close to the specified surfels.

-# KSpace methods
  - Shortcuts::parametersKSpace: parameters related to Khalimsky spaces (closed)
  - Shortcuts::getKSpace: overloaded methods for building a Khalimsky space from a domain or an image, from a bounding box, or from a digitization process.

-# DigitizedImplicitShape3D methods
  - Shortcuts::parametersDigitizedImplicitShape3D: parameters related to shape digitization (bounding box, sampling)
  - Shortcuts::makeDigitizedImplicitShape3D: digitizes an implicit shape.

-# BinaryImage methods
  - Shortcuts::parametersBinaryImage: parameters related to binary images (noise, threshold).
  - Shortcuts::makeBinaryImage: many overloaded methods for creating from scratch, vectorizing shape digitization, loading, copying/noisifying binary images, thresholding gray-scale images.
  - Shortcuts::saveBinaryImage: saves a binary image to a file.

-# GrayScaleImage methods
  - Shortcuts::makeGrayScaleImage: overloaded methods for creating from scratch or from binary image, or for loading gray scale images, or for creating a gray-scale image from a float or double image.
  - Shortcuts::saveGrayScaleImage: saves a gray scale image to a file.

-# FloatImage methods
  - Shortcuts::makeFloatImage: overloaded methods for creating a float image from a domain or from an implicit shape.

-# DoubleImage methods
  - Shortcuts::makeDoubleImage: overloaded methods for creating a double image from a domain or from an implicit shape.

-# DigitalSurface methods
  - Shortcuts::parametersDigitalSurface: parameters related to digital surfaces (surfel adjacency, components, internal heuristics)
  - Shortcuts::makeLightDigitalSurface: creates a light connected surface around a (random) big enough component of a binary image 
  - Shortcuts::makeLightDigitalSurfaces: creates the vector of all light digital surfaces of the binary image or any one of its big components, can also output representant surfels
  - Shortcuts::makeDigitalSurface: creates an arbitrary (connected or not) digital surface from a binary image or from an indexed digital surface.
  - Shortcuts::makeIdxDigitalSurface: creates an indexed digital surfaces that represents all the boundaries of a binary image or any one of its big components, or any given collection of surfels, or from light digital surface(s).
  - Shortcuts::getSurfelRange: returns the surfels of a digital surface in the specified traversal order.
  - Shortcuts::getIdxSurfelRange: returns the indexed surfels of an indexed digital surface in the specified traversal order.

-# GeometryEstimation services
  - Shortcuts::getTrivialNormalVectors: returns the trivial (Trivial) normal vectors to the given surfel range  
  - Shortcuts::getCTrivialNormalVectors: returns the convolved trivial (CTrivial) normal vectors to the given surfel range
  - Shortcuts::getVCMNormalVectors: returns the Voronoi Covariance Measure (VCM) normal vectors to the given surfel range
  - Shortcuts::getIINormalVectors: returns the Integral Invariant (II) normal vectors to the given surfel range

-# Mesh services
  - Shortcuts::makeTriangulatedSurface: builds the dual triangulated surface approximating an arbitrary digital surface, or the triangulated surface covering a given mesh, or subdivide a polygonal surface into a triangulated surface, or builds the marching cubes triangulated surface approximating an isosurface in a gray-scale image. 
  - Shortcuts::makePolygonalSurface: builds a polygonal surface from a mesh, or builds the marching cubes polygonal surface approximating an isosurface in a gray-scale image. 
  - Shortcuts::makePrimalPolygonalSurface: builds the primal polygonal surface of a digital surface
  - Shortcuts::makeDualPolygonalSurface: builds the dual polygonal surface of a digital surface
  - Shortcuts::saveOBJ: saves a triangulated or polygonal surface as an OBJ file, with optionnaly normals and colors information.

-# Utilities
  - Shortcuts::getColormap: returns the specified colormap.
  - Shortcuts::getTicsColormap: returns the specified colormap used for tics.
  - Shortcuts::getRangeMatch: returns the perfect or approximate  match/correspondence between two ranges.
  - Shortcuts::getMatchedRange: returns the perfectly or approximately matched/corresponding range.
  - Shortcuts::getPrimalVertices: returns the vertices (possibly consistently ordered along the face) of the given signed cell.
  - Shortcuts::outputSurfelsAsObj: outputs surfels in standard OBJ file format.
  - Shortcuts::outputPrimalDigitalSurfaceAsObj: outputs any digital surface in standard OBJ file format as its primal quadrangulated mesh.
  - Shortcuts::outputPrimalIdxDigitalSurfaceAsObj: outputs any indexed digital surface in standard OBJ file format as its primal quadrangulated mesh.
  - Shortcuts::outputDualDigitalSurfaceAsObj: outputs any digital surface in standard OBJ file format as its dual polygonal or triangulated mesh.
  - Shortcuts::outputDualIdxDigitalSurfaceAsObj: outputs any indexed digital surface in standard OBJ file format as its dual polygonal or triangulated mesh.


@subsection dgtal_shortcuts_ssec3_4 Parameters

In all methods, \b out parameters are listed before \b in parameters.
Also, methods whose result can be influenced by global parameters are
parameterized through a Parameters object. Hence static methods follow this pattern:

\a <return-type> Shortcuts::`fonction-name` ( [ \a <out-parameter(s)> ], [ \a <in-parameter(s)> ], [ Parameters params ] ) 

The simplest way to get default values for global parameters is to
start with a line:

\code
auto params = Shortcuts<KSpace>::defaultParameters();
\endcode

And then to change your parameter settings with Parameters::operator(), for instance:

\code
params( "gridstep", 0.1 )( "closed", 1 );
\endcode

You also have the bitwise-or (`operator|`) to merge Parameters.

*/

}
