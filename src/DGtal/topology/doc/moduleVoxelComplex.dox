
/*
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**

@page moduleVoxelComplex  Voxel Complex

@writers Pablo Hernandez-Cerdan

@since 0.9.4

Part of the \ref packageTopology.

This part of the manual describes how to represent and process
arbitrary voxel complexes, which are cubical complexes with an associated DigitalObject.

[TOC]


The following programs are related to this documentation:
testVoxelComplex.cpp.

@section dgtal_vcomplex_sec1  Introduction to voxel complexes

The aim is to implement critical kernels, ie, cliques of spels,
as shown by M.Couprie and G.Bertrand in @cite Couprie201622 .

Implemented using resources from \a CubicalComplex and
(Digital) \a Object for simplicity check in voxels.

A \b voxel \b complex \a V is a \b cubical \b complex (living in a Khalimsky space) with a member of type DigitalObject. Voxel complexes are used for thinning in 3D.

To create a voxel complex, we need to specify in which Khalimsky
space it lives and also, optionally, the type of container used for
storing cells. By default it is \c std::map but \c boost::unordered_map
or \c std::unordered_map is also possible.

\code
using namespace DGtal;
using KSpace = DGtal::Z3i::KSpace;      // ZxZxZ
using Domain = DGtal::Z3i::Domain
using DigitalTopology = DGtal::Z3i::DT26_6;
using DigitalSet =  DGtal::DigitalSetByAssociativeContainer<
    DGtal::Z3i::Domain,
    std::unordered_set< typename DGtal::Z3i::Domain::Point> >;
using Object = DGtal::Object<DigitalTopology, DigitalSet>;
using Complex = DGtal::VoxelComplex<KSpace, Object>;    // Type of VoxelComplex.

KSpace ks;                                               // The cellular grid space
ks.init( Point( 0,0,0 ), Point( 100,100,100 ), true );   // Limits of the grid space
// Voxel Complex needs a KSpace and can be populated with an object.
// Create the object from a digital set and topology
Point p1(-10, -10, -10);
Point p2(10, 10, 10);
Domain domain(p1, p2);
Point c(0, 0, 0);
DigitalSet a_set(domain);
DigitalTopology::ForegroundAdjacency adjF;
DigitalTopology::BackgroundAdjacency adjB;
DigitalTopology topo( adjF, adjB, DGtal::DigitalTopologyProperties::JORDAN_DT);

auto object = Object(topo, a_set);

Complex complex( ks );
complex.construct( object );

\endcode

Last, there is a data associated with each cell of a complex. The data
type must either be CubicalCellData or a type that derives from
CubicalCellData. This data is used by the thinning algorithm with persistence.
But can be used for other purposes, take a look at the documentation
of CubicalCellData to see the default stored flags and data.

@section dgtal_vcomplex_sec2 Thinning in voxel complexes

The thinning algorithm is based on @cite Couprie201622, and the two
algorithms from there are implemented, @asymetricThinningScheme
and @persistenceAsymetricThinningScheme. These algorithms are homeotopic, keeping the topology of the original object.

The only difference between both algorithms is the \b persistence parameter, which allow to perform trimming on spurious or branches generated by noise.

Both algorithms take two kind of functions as arguments:

Select functions: The asymetric nature of the algorithm requires we select points from the whole set at each step.
 - random: One point at random from the set.
 - first: The first point of the ordered set by lexicographical order.
 - dmax: In conjunction with a distance map, this function selects the point with largest value of the map.

Skeleton functions:
 - ulti: the ultimate skeleton, doesn't keep any extra voxel, and the skeleton consist in the minimal set of points with the same topology than the input shape.
 - end: Keep the end points generated in the thinning process.
 - 1isthmus: Keep the one-isthmuses found in the process.
 - isthmus: Keep the one-isthmus and the two-isthmuses.

"Intuitively a voxel x of an object X is said to be a 1-isthmus (resp. a 2-isthmus) if the neighborhood of x corresponds -up to a thinning- to the one of a point belonging to a curve (resp. a surface)."
We say that the complex X is reducible only if it is possible to reduce it to a single voxel.

\b Critical \b Kernels

If we remove simple voxels in parallel is known we may change its topology. To avoid it, we use a framework called critical kernels and to do that we define what is a \a Clique.

Let $ d \in {0,1,2,3} $ and let $ C \in V^3 $ with V^3 being the collection of all voxel complexes (a finite set composed solely of voxels). We say that C is a d-clique if the intersection of all voxels of C is a d-face.

Any complex C made of a single voxel is a 3-clique. Furthermore, any voxel of a complex constitutes a 3-clique that is \a essential for X. Essential is the minimal clique for X.

We now arrive to the last definitions, \a K-neighborhood of a voxel S, written K(S) is the set of all voxels adjacent to S. And K*(S) = K \ S.

We say that the clique C is \a regular for  X if K*(C) intersection X is reductible. We say that C is \a critical for X if C is not regular.

Note that if C is a single voxel x, then C is regular for X, only if x is simple for X.

And finally, the complex Y is a thinning  of X if any clique  that is critical for X, contains at least one voxel of Y.

\b Implementation

In summary, the core of the implementation is the selection of the critical d-cliques for the complex X.
*/

}
