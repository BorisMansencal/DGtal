/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MeshVoxelizer.ih
 *
 * @date 2016/01/24
 *
 * Implementation of inline methods defined in MeshVoxelizer.h
 *
 * This file is part of the DGtal library.
 */

/////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
/////////////////////////////////////////////////////////////////////////////
#include <algorithm>
/////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services --------------------------------

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
DGtal::MeshVoxelizer<TDigitalSet, Separation>::MeshVoxelizer()
{

  if(Separation == 6)
  {
    // 26 connected - 6 separated
    PointR3 AA(0.5, 0, 0);
    PointR3 BB(-0.5, 0, 0);
    PointR3 CC(0, 0, 0.5);
    PointR3 DD(0, 0, -0.5);
    PointR3 EE(0, 0.5, 0);
    PointR3 FF(0, -0.5, 0);

    myIntersectionTarget.push_back( Edge(AA, BB) );
    myIntersectionTarget.push_back( Edge(CC, DD) );
    myIntersectionTarget.push_back( Edge(EE, FF) );
  }
  else if(Separation == 26)
  {
    // 6 connected - 26 separated
    PointR3 AA(-0.5, 0.5, 0.5);
    PointR3 BB(0.5, 0.5, 0.5);
    PointR3 CC(0.5, 0.5, -0.5);
    PointR3 DD(-0.5, 0.5, -0.5);
    PointR3 EE(-0.5, -0.5, 0.5);
    PointR3 FF(0.5, -0.5, 0.5);
    PointR3 GG(0.5, -0.5, -0.5);
    PointR3 HH(-0.5, -0.5, -0.5);

    myIntersectionTarget.push_back( Edge(AA, GG) );
    myIntersectionTarget.push_back( Edge(BB, HH) );
    myIntersectionTarget.push_back( Edge(CC, EE) );
    myIntersectionTarget.push_back( Edge(DD, FF) );

    // compute base foreach normal

    // normal
    std::vector<VectorR3> myNormal(4);
    myNormal[0] = VectorR3( 1, -1, -1).getNormalized(); // AG
    myNormal[1] = VectorR3(-1, -1, -1).getNormalized(); // BH
    myNormal[2] = VectorR3(-1, -1,  1).getNormalized(); // CE
    myNormal[3] = VectorR3( 1, -1,  1).getNormalized(); // DF

    // base
    myE1base.resize(4);
    myE2base.resize(4);
    for(int i = 0; i < 4; i++) {
      auto& x = myNormal[i][0];
      auto& y = myNormal[i][1];
      auto& z = myNormal[i][2];

      myE1base[i] = std::move( VectorR3(-y, x, 0).getNormalized() );
      myE2base[i] = std::move( VectorR3(-x*z, -y*z, x*x + y*y).getNormalized() );
    }
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
double
DGtal::MeshVoxelizer<TDigitalSet, Separation>::distance(const PointR3& M,
                                                        const VectorR3& n,
                                                        const PointZ3& voxel)
{
  ASSERT( n.norm()!=0 );
  double distance = 0.;
  double d = n.dot(M);

  distance = n.dot(voxel) - d;

  if(distance < 0)
    distance *= -1;

  distance /= n.norm();

  return distance;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
typename DGtal::MeshVoxelizer<TDigitalSet, Separation>::TriangleOrientation
DGtal::MeshVoxelizer<TDigitalSet, Separation>::pointIsInside2DTriangle(const PointR2& A,
                                                                       const PointR2& B,
                                                                       const PointR2& C,
                                                                       const PointR2& v)
{
  // AC
  double val1 = (C[1] - A[1])*(v[0] - A[0]) + (C[0] - A[0])*(A[1] - v[1]);
  // CB
  double val2 = (B[1] - C[1])*(v[0] - C[0]) + (B[0] - C[0])*(C[1] - v[1]);
  // BA
  double val3 = (A[1] - B[1])*(v[0] - B[0]) + (A[0] - B[0])*(B[1] - v[1]);

  // 0 : outside
  // 1 : inside
  // 2 : on edge
  // 3 : on vertex
  if( ( val1 == 0 && val2 == 0 ) ||
      ( val1 == 0 && val3 == 0 ) ||
      ( val2 == 0 && val3 == 0 ) ) {
    return ONVERTEX;
  }
  else if(val1 == 0 || val2 == 0 || val3 == 0)
    return ONEDGE;
  else if(val1 < 0 || val2 < 0 || val3 < 0)
    return OUTSIDE;
  else
    return INSIDE;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
bool
DGtal::MeshVoxelizer<TDigitalSet, Separation>::pointIsInsideVoxel(const PointR3& P,
                                                                  const PointZ3& v)
{
  PointR3 PP = P - v;
  for(int i(0); i < 3; i++)
    if(! (-0.5 <= PP[i] && PP[i] <= 0.5) )
      return false;

  return true;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, Separation>::voxelizeTriangle(DigitalSet &outputSet,
                                                                std::integral_constant<size_t, 6>,
                                                                const PointR3& A,
                                                                const PointR3& B,
                                                                const PointR3& C,
                                                                const VectorR3& n,
                                                                const std::pair<PointR3, PointR3>& bbox)
{
  OrientationFunctor orientationFunctor;

  //geometric predicate
  PredicateFromOrientationFunctor2<OrientationFunctor> pointPredicate( orientationFunctor );

  PointR2 AA, BB, CC;
  PointZ3 v;

  // foreach intersection target
  for(Edge& target : myIntersectionTarget)
  {
    // 2D projection of A ; B ; C
    if(target.myFirst[0] == 0.5) {
      // ignore X composante
      AA[0] = A[1];
      BB[0] = B[1];
      CC[0] = C[1];

      AA[1] = A[2];
      BB[1] = B[2];
      CC[1] = C[2];
    }
    else if(target.myFirst[1] == 0.5)
    {
      // ignore Y composante
      AA[0] = A[0];
      BB[0] = B[0];
      CC[0] = C[0];

      AA[1] = A[2];
      BB[1] = B[2];
      CC[1] = C[2];
    }
    else
    {
      // ignore Z composante
      AA[0] = A[0];
      BB[0] = B[0];
      CC[0] = C[0];

      AA[1] = A[1];
      BB[1] = B[1];
      CC[1] = C[1];
    }

    // check orientation
    if(! pointPredicate(AA, BB, CC))
      std::swap(AA, CC);

    // traverse all voxel of current face bounding box
    v = bbox.first;
    for(; v[1] <= bbox.second[1]; v[1]++)
      for(v[0] = bbox.first[0]; v[0] <= bbox.second[0]; v[0]++)
        for(v[2] = bbox.first[2]; v[2] <= bbox.second[2]; v[2]++)
        {
          // check if points are on different side
          target.myFirst += v;
          target.mySecond += v;

          VectorR3 a2myFirst = A - target.myFirst;
          VectorR3 a2mySecond = A - target.mySecond;

          VectorR3 w = target.mySecond - target.myFirst;
          double den = n.dot(w);

          bool isSameSide = den == 0 // target on plane
            || ( a2myFirst.dot(n) * a2mySecond.dot(n) > 0 ); // target on one side

          target.myFirst -= v;
          target.mySecond -= v;

          if( isSameSide )
            continue;

          PointR2 pp;

          // 2d projection of current voxel
          if(target.myFirst[0] == 0.5) {
            // ignore X composante
            pp[0] = v[1];
            pp[1] = v[2];
          }
          else if(target.myFirst[1] == 0.5)
          {
            // ignore Y composante
            pp[0] = v[0];
            pp[1] = v[2];
          }
          else
          {
            // ignore Z composante
            pp[0] = v[0];
            pp[1] = v[1];
          }

          // check if current voxel projection is inside ABC projection
          if(pointIsInside2DTriangle(AA, BB, CC, pp) != OUTSIDE)
            outputSet.insert(v);
        }
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, Separation>::voxelizeTriangle(DigitalSet &outputSet,
                                                                std::integral_constant<size_t, 26>,
                                                                const PointR3& A,
                                                                const PointR3& B,
                                                                const PointR3& C,
                                                                const VectorR3& n,
                                                                const std::pair<PointR3, PointR3>& bbox)
{
  OrientationFunctor orientationFunctor;

  //geometric predicate
  PredicateFromOrientationFunctor2<OrientationFunctor> pointPredicate( orientationFunctor );

  double d = n[0] * C[0] + n[1] * C[1] + n[2] * C[2];
  d *= -1;

  PointR2 AA, BB, CC;
  PointZ3 v;
  PointR2 pp;

  // foreach intersection target
  for(unsigned int i(0); i < myIntersectionTarget.size(); i++)
  {
    Edge& target = myIntersectionTarget[i];

    // 2D projection of A ; B ; C
    AA[0] = myE1base[i].dot(A);
    AA[1] = myE2base[i].dot(A);

    BB[0] = myE1base[i].dot(B);
    BB[1] = myE2base[i].dot(B);

    CC[0] = myE1base[i].dot(C);
    CC[1] = myE2base[i].dot(C);

    if(! pointPredicate(AA, BB, CC))
      std::swap(AA, CC);

    // traverse all voxel of current face bounding box
    v = bbox.first;
    for(; v[1] <= bbox.second[1]; v[1]++)
      for(v[0] = bbox.first[0]; v[0] <= bbox.second[0]; v[0]++)
        for(v[2] = bbox.first[2]; v[2] <= bbox.second[2]; v[2]++)
        {
          // check if points are on different side
          target.myFirst += v;
          target.mySecond += v;

          VectorR3 a2myFirst = A - target.myFirst;
          VectorR3 a2mySecond = A - target.mySecond;

          VectorR3 w = target.mySecond - target.myFirst;
          double den = n.dot(w);

          bool isSameSide = den == 0 // target on plane
            || ( a2myFirst.dot(n) * a2mySecond.dot(n) > 0 ); // target on one side

          // if target is on the same side -> skip current iteration
          if( isSameSide )
          {
            target.myFirst -= v;
            target.mySecond -= v;
            continue;
          }

          pp[0] = myE1base[i].dot(target.myFirst);
          pp[1] = myE2base[i].dot(target.myFirst);

          // check if current voxel projection is inside ABC projection
          if( pointIsInside2DTriangle(AA, BB, CC, pp) != OUTSIDE )
            outputSet.insert(v);

          target.myFirst -= v;
          target.mySecond -= v;
        }
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, Separation>::voxelize(DigitalSet &outputSet,
                                                        const PointR3 &a,
                                                        const PointR3 &b,
                                                        const PointR3 &c,
                                                        const double scaleFactor)
{
  std::pair<PointR3, PointR3> bbox;
  VectorR3 n, e1, e2;
  PointR3 A, B, C;

  A = a*scaleFactor;
  B = b*scaleFactor;
  C = c*scaleFactor;

  e1 = B - A;
  e2 = C - A;
  n = e1.crossProduct(e2).getNormalized();

  //Boundingbox
  bbox.first = A;
  bbox.second = A;
  bbox.first = bbox.first.inf( B );
  bbox.first = bbox.first.inf( C );
  bbox.second = bbox.second.sup( B );
  bbox.second = bbox.second.sup( C );

  ASSERT( bbox.first <= bbox.second);

  //Rounding the bbox
  std::transform( bbox.first.begin(), bbox.first.end(), bbox.first.begin(),
                  [](typename PointR3::Component cc) { return std::floor(cc);});
  std::transform( bbox.second.begin(), bbox.second.end(), bbox.second.begin(),
                  [](typename PointR3::Component cc) { return std::ceil(cc);});

  // voxelize current triangle to myDigitalSet
  voxelizeTriangle( outputSet, A, B, C, n, bbox);
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t Separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, Separation>::voxelize(DigitalSet &outputSet,
                                                        const Mesh<PointR3> &aMesh,
                                                        const double scaleFactor)
{
  MeshFace currentFace;
  std::pair<PointR3, PointR3> bbox;

  VectorR3 n, e1, e2;
  PointR3 A, B, C;

  for(unsigned int i = 0; i < aMesh.nbFaces(); i++)
  {
    //std::cout << "\rvoxelize face [" << i << "] out of [" << aMesh.nbFaces() << "]" << std::flush;
    currentFace = aMesh.getFace(i);
    voxelize(outputSet, aMesh.getVertex(currentFace[0]),
             aMesh.getVertex(currentFace[1]),
             aMesh.getVertex(currentFace[2]),
             scaleFactor);
  }
}
