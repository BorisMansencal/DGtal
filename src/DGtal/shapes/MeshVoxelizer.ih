/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MeshVoxelizer.ih
 *
 * @date 2016/01/24
 *
 * Implementation of inline methods defined in MeshVoxelizer.h
 *
 * This file is part of the DGtal library.
 */

/////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services --------------------------------

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
DGtal::MeshVoxelizer<TDigitalSet, separation>::MeshVoxelizer(ConstAlias<Mesh3>  aMesh,
                               ConstAlias<Domain> aDomain, size_t aResolution)
  : myMesh(&aMesh), myDigitalSet(&aDomain)
{
  std::pair<PointR3, PointR3> bbox = myMesh.getBoundingBox();

  myMesh.changeScale(aResolution / bbox.second[0]);

  if(separation == 6)
  {
    // 26 connected - 6 separated
    PointR3 AA(0.5, 0, 0);
    PointR3 BB(-0.5, 0, 0);
    PointR3 CC(0, 0, 0.5);
    PointR3 DD(0, 0, -0.5);
    PointR3 EE(0, 0.5, 0);
    PointR3 FF(0, -0.5, 0);

    myIntersectionTarget.push_back( Edge(AA, BB) );
    myIntersectionTarget.push_back( Edge(CC, DD) );
    myIntersectionTarget.push_back( Edge(EE, FF) );
  }
  else if(separation == 26)
  {
    // 6 connected - 26 separated
    PointR3 AA(-0.5, 0.5, 0.5);
    PointR3 BB(0.5, 0.5, 0.5);
    PointR3 CC(0.5, 0.5, -0.5);
    PointR3 DD(-0.5, 0.5, -0.5);
    PointR3 EE(-0.5, -0.5, 0.5);
    PointR3 FF(0.5, -0.5, 0.5);
    PointR3 GG(0.5, -0.5, -0.5);
    PointR3 HH(-0.5, -0.5, -0.5);

    myIntersectionTarget.push_back( Edge(AA, GG) );
    myIntersectionTarget.push_back( Edge(BB, HH) );
    myIntersectionTarget.push_back( Edge(CC, EE) );
    myIntersectionTarget.push_back( Edge(DD, FF) );
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
double
DGtal::MeshVoxelizer<TDigitalSet, separation>::distance(const PointR3& M,
          const VectorR3& n, const PointZ3& voxel) 
{
  double distance = 0.;
  double d = n.dot(M);

  distance = n.dot(voxel) - d;

  if(distance < 0)
    distance *= -1;

  distance /= n.norm();

  return distance;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
typename DGtal::MeshVoxelizer<TDigitalSet, separation>::TriangleOrientation
DGtal::MeshVoxelizer<TDigitalSet, separation>::pointIsInside2DTriangle(const PointR2& A, const PointR2& B, const PointR2& C, const PointR2& v)
{
  // AC
  double val1 = (C[1] - A[1])*(v[0] - A[0]) + (C[0] - A[0])*(A[1] - v[1]);
  // CB
  double val2 = (B[1] - C[1])*(v[0] - C[0]) + (B[0] - C[0])*(C[1] - v[1]);
  // BA
  double val3 = (A[1] - B[1])*(v[0] - B[0]) + (A[0] - B[0])*(B[1] - v[1]);

  // 0 : outside
  // 1 : inside
  // 2 : on edge
  // 3 : on vertex
  if( ( val1 == 0 && val2 == 0 ) ||
      ( val1 == 0 && val3 == 0 ) ||
      ( val2 == 0 && val3 == 0 ) )
    return ONVERTEX;
  else if(val1 == 0 || val2 == 0 || val3 == 0)
    return ONEDGE;
  else if(val1 < 0 || val2 < 0 || val3 < 0)
    return OUTSIDE;
  else
    return INSIDE;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
bool
DGtal::MeshVoxelizer<TDigitalSet, separation>::pointIsInsideVoxel(const PointR3& P, const PointZ3& v)
{
  PointR3 PP = P - v;
  for(int i(0); i < 3; i++)
    if(! (-0.5 <= PP[i] && PP[i] <= 0.5) )
      return false;
   
  return true;
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, separation>::voxelizeTriangle(std::integral_constant<size_t, 6>, const PointR3& A, const PointR3& B, const PointR3& C, const VectorR3& n, const std::pair<PointR3, PointR3>& bbox)
{
  OrientationFunctor orientationFunctor;

  //geometric predicate
  PredicateFromOrientationFunctor2<OrientationFunctor> pointPredicate( orientationFunctor );

  PointR2 AA, BB, CC, tmp;
  PointZ3 v;

  // foreach intersection target
  for(Edge& target : myIntersectionTarget)
  {
    // 2D projection of A ; B ; C

    if(target.f[0] == 0.5) {
      // ignore X composante
      AA[0] = A[1];
      BB[0] = B[1];
      CC[0] = C[1];

      AA[1] = A[2];
      BB[1] = B[2];
      CC[1] = C[2];
    }
    else if(target.f[1] == 0.5)
    {
      // ignore Y composante
      AA[0] = A[0];
      BB[0] = B[0];
      CC[0] = C[0];

      AA[1] = A[2];
      BB[1] = B[2];
      CC[1] = C[2];
    }
    else
    {
      // ignore Z composante
      AA[0] = A[0];
      BB[0] = B[0];
      CC[0] = C[0];

      AA[1] = A[1];
      BB[1] = B[1];
      CC[1] = C[1];
    }

    // check orientation
    if(! pointPredicate(AA, BB, CC))
    {
      tmp = AA;
      AA  = CC;
      CC  = tmp;
    }

    // traverse all voxel of current face bounding box
    v = bbox.first;
    for(; v[1] <= bbox.second[1]; v[1]++)
      for(v[0] = bbox.first[0]; v[0] <= bbox.second[0]; v[0]++)
        for(v[2] = bbox.first[2]; v[2] <= bbox.second[2]; v[2]++)
        {
          // check if points are on different side
          target.f += v;
          target.s += v;

          VectorR3 d1, d2;

          d1 = A - target.f;
          d2 = A - target.s;

          bool isDifferentSide = d1.dot(n) * d2.dot(n) <= 0;

          target.f -= v;
          target.s -= v;

          if( ! isDifferentSide )
            continue;

          PointR2 pp;

          // 2d projection of current voxel
          if(target.f[0] == 0.5) {
            // ignore X composante
            pp[0] = v[1];
            pp[1] = v[2];
          }
          else if(target.f[1] == 0.5)
          {
            // ignore Y composante
            pp[0] = v[0];
            pp[1] = v[2];
          }
          else
          {
            // ignore Z composante
            pp[0] = v[0];
            pp[1] = v[1];
          }

          // check if current voxel projection is inside ABC projection
          if(pointIsInside2DTriangle(AA, BB, CC, pp) != 0)
            myDigitalSet.insert(v);
        }
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, separation>::voxelizeTriangle(std::integral_constant<size_t, 26>, const PointR3& A, const PointR3& B, const PointR3& C, const VectorR3& n, const std::pair<PointR3, PointR3>& bbox)
{
  OrientationFunctor orientationFunctor;

  //geometric predicate
  PredicateFromOrientationFunctor2<OrientationFunctor> pointPredicate( orientationFunctor );

  double d = n[0] * C[0] + n[1] * C[1] + n[2] * C[2];
  d *= -1;

  // lambda function to return compute intersection point (p)
  // intersection point between Edge a and ABC triangle
  auto intersectionPoint =
    [&](Edge a, PointR3& p)
    {
      // point d'intersection
      VectorR3 w; // vecteur directeur

      w = a.s - a.f;

      double lambda = -( n.dot(a.f) + d );
      double den = n.dot(w);

      ASSERT(den != 0);

      lambda /= den;

      p[0] = a.f[0] + lambda*w[0];
      p[1] = a.f[1] + lambda*w[1];
      p[2] = a.f[2] + lambda*w[2];

    };

  auto abs = [=](double a) { return a < 0 ? -a : a; };
  auto max = [=](double a, double b) { return abs(a) > abs(b) ? a : b; };

  double maxv = max(n[0], max(n[1], n[2]));

  PointZ3 v;
  PointR2 AA, BB, CC, tmp, pp;

  // 2D projection of ABC
  if(maxv == n[0])
  {
    AA[0] = A[1];
    AA[1] = A[2];

    BB[0] = B[1];
    BB[1] = B[2];

    CC[0] = C[1];
    CC[1] = C[2];
  }
  else if(maxv == n[1])
  {
    AA[0] = A[0];
    AA[1] = A[2];

    BB[0] = B[0];
    BB[1] = B[2];

    CC[0] = C[0];
    CC[1] = C[2];
  }
  else
  {
    AA[0] = A[0];
    AA[1] = A[1];

    BB[0] = B[0];
    BB[1] = B[1];

    CC[0] = C[0];
    CC[1] = C[1];
  }

  // check orientation
  if(! pointPredicate(AA, BB, CC))
  {
    tmp = AA;
    AA = CC;
    CC = tmp;
  }

  // foreach intersection target
  for(Edge& target : myIntersectionTarget)
  {
    // traverse all voxel of current face bounding box
    v = bbox.first;
    for(; v[1] <= bbox.second[1]; v[1]++)
      for(v[0] = bbox.first[0]; v[0] <= bbox.second[0]; v[0]++)
        for(v[2] = bbox.first[2]; v[2] <= bbox.second[2]; v[2]++)
        {
          // check if points are on different side
          target.f += v;
          target.s += v;

          VectorR3 d1, d2;

          d1 = A - target.f;
          d2 = A - target.s;

          bool isDifferentSide = d1.dot(n) * d2.dot(n) <= 0;

          if( ! isDifferentSide )
          {
            target.f -= v;
            target.s -= v;
            continue;
          }

          // get intersection point between target intersection and ABC
          PointR3 p; // intersection point to compute
          if( ! intersectionPoint(target, p)) // false if target is on ABC plane
          {
            target.f -= v;
            target.s -= v;
            continue;
          }

          // 2d projection of intersection point
          if(maxv == n[0])
          {
            pp[0] = p[1];
            pp[1] = p[2];
          }
          else if(maxv == n[1])
          {
            pp[0] = p[0];
            pp[1] = p[2];
          }
          else
          {
            pp[0] = p[0];
            pp[1] = p[1];
          }

          // check if current voxel projection is inside ABC projection
          if(pointIsInside2DTriangle(AA, BB, CC, pp) != 0)
            myDigitalSet.insert(v);

          target.f -= v;
          target.s -= v;
        }
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
void
DGtal::MeshVoxelizer<TDigitalSet, separation>::voxelize()
{
  MeshFace currentFace;
  std::pair<PointR3, PointR3> bbox;

  VectorR3 n, e1, e2;
  PointR3 A, B, C;

  for(int i = 0; i < myMesh.nbFaces(); i++)
  {
    currentFace = myMesh.getFace(i);

    A = myMesh.getVertex(currentFace[0]);
    B = myMesh.getVertex(currentFace[1]);
    C = myMesh.getVertex(currentFace[2]);

    e1 = B - A;
    e2 = C - A;
    n = e1.crossProduct(e2).getNormalized();

    Mesh<PointR3> currentMesh;
    currentMesh.addVertex(A);
    currentMesh.addVertex(B);
    currentMesh.addVertex(C);
    currentMesh.addTriangularFace(0, 1, 2);

    bbox = currentMesh.getBoundingBox();

    // floor and ceil to have an axis aligned bounding box in Z^3
    for(int j(0); j < 3; j++)
    {
      if(bbox.first[j] < bbox.second[j])
      {
        bbox.first[j] = floor(bbox.first[j]);
        bbox.second[j] = ceil(bbox.second[j]);
      }
      else
      {
        bbox.second[j] = floor(bbox.second[j]);
        bbox.first[j] = ceil(bbox.first[j]);
      }

      if(bbox.first[j] > bbox.second[j])
      {
        // swap
        double tmp = bbox.first[j];
        bbox.first[j] = bbox.second[j];
        bbox.second[j] = tmp;
      }
    }

    // voxelize current triangle to myDigitalSet
    voxelizeTriangle(A, B, C, n, bbox);
  }
}

// ---------------------------------------------------------
template <typename TDigitalSet, size_t separation>
inline
const TDigitalSet&
DGtal::MeshVoxelizer<TDigitalSet, separation>::digitalSet() const
{
  return this->myDigitalSet;
}
